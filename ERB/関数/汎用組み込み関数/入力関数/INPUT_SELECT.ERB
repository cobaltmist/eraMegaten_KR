;-------------------------------------------------
;선택지제시＋입력 함수 @INPUT_SELECT
;[ARG:0]ARGS:0	[ARG:1]ARGS:1
;[ARG:2]ARGS:2	[ARG:3]ARGS:3
;ARG에 0은 사용할 수 없으니 주의
;-------------------------------------------------
@INPUT_SELECT(ARG:0 = 0, ARGS , ARG:1= 0, ARGS:1, ARG:2= 0, ARGS:2, ARG:3= 0, ARGS:3, ARG:4= 0, ARGS:4, ARG:5= 0, ARGS:5, ARG:6= 0, ARGS:6, ARG:7= 0, ARGS:7, ARG:8= 0, ARGS:8, ARG:9= 0, ARGS:9, ARG:10= 0, ARGS:10, ARG:11= 0, ARGS:11, ARG:12= 0, ARGS:12, ARG:13= 0, ARGS:13, ARG:14= 0, ARGS:14, ARG:15= 0, ARGS:15, ARG:16= 0, ARGS:16, ARG:17= 0, ARGS:17, ARG:18= 0, ARGS:18, ARG:19= 0, ARGS:19)
#LOCALSIZE 4
;문자열 길이를 취득
LOCAL:1 = 0
LOCAL:2 = 0
FOR LOCAL,0,20
	SIF STRLENS(ARGS:LOCAL) > LOCAL:1
		LOCAL:1 = STRLENS(ARGS:LOCAL)
NEXT
FOR LOCAL,0,20
	SIF STRLENS(TOSTR(ARG:LOCAL)) > LOCAL:2
		LOCAL:2 = STRLENS(TOSTR(ARG:LOCAL))
NEXT
LOCAL:3 = 0
;선택지를 표시
FOR LOCAL,0,20
	IF ARG:LOCAL != 0
		PRINTFORM [{ARG:LOCAL,LOCAL:2}] %ARGS:LOCAL,LOCAL:1,LEFT%　　
		LOCAL:3 += 1
		SIF LOCAL:3 % 2 == 0
			PRINTL
	ENDIF
NEXT
;선택지의 입력 판정
$INPUT_LOOP
IF LOCAL:2 == 1
	ONEINPUT
ELSE
	INPUT
ENDIF
;일치하는 ARG가 없으면 다시 입력
IF RESULT == 0 || MATCH(ARG,RESULT,0, 21) == 0
	CLEARLINE 1
	REUSELASTLINE 
	GOTO INPUT_LOOP
ENDIF
RETURN RESULT