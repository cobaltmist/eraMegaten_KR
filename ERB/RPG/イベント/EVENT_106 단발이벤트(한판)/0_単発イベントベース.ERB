; ;일판 단발이벤트를 사용한 개조이식

; ;이벤트는 전부 비트연산을 사용
; ;개조)	이벤트1당 2개의 비트를 사용, 미감상 체크
; ;		그 관계로 한 변수에 저장할 수 있는 비트의 수는 64개에서 32개로 감소
; ;이벤트베이스는 내부処理に特化し、【이벤트作りたい人が見なくてもいい部分】として独立化。

; ;====================
; ;조건
; ;====================
; @PLAYABLE_EVENT_19
; #LOCALSIZE 3
; #DIM L_INDEX
; VARSET LOCAL
; ;인덱스 참조
; ;참조하는 배열과 BIT값을 얻기위한 2중루프
; ;현재는 10×32의 320개까지 작성할 수 있는 계산。
; ;늘리고 싶다면 ↓ 행의 "LOCAL, 0, 10"의 마지막 10을 늘리면 OK(최대100)
; FOR L_INDEX,0,20
; 	FOR LOCAL,0,32
; 		TRYCCALLFORM EVENT_19_LIST_{L_INDEX} , LOCAL,1
; 		CATCH
; 			BREAK
; 		ENDCATCH
; 		SIF !RESULT
; 			CONTINUE
; 		SIF GETBIT(이벤트フラグ:19:L_INDEX,LOCAL)
; 			CONTINUE
; 		IF !GETBIT(이벤트フラグ:19:L_INDEX,LOCAL+32)
; 			SETBIT 이벤트フラグ:19:L_INDEX,LOCAL+32
; 			CALLFORM EVENT_19_LIST_{L_INDEX} , LOCAL,0
; 			LOCALS = 단발이벤트【%RESULTS%】가 출현！
; 			CALL MESSAGE_B(1, LOCALS)
; 		ENDIF
; 		;まだ見てない이벤트の数をカウント
; 		SIF !GETBIT(이벤트フラグ:19:L_INDEX,LOCAL)
; 			LOCAL:1++
; 		LOCAL:2++
; 	NEXT
; NEXT
; IF LOCAL:1 > 0
; 	RESULTS = 단발이벤트\(신규{LOCAL:1}개\)
; ELSE
; 	RESULTS = 단발이벤트
; ENDIF
; SIF LOCAL:2
; 	RETURN 1

; ;====================
; ;内容
; ;====================
; @SHOPCOM_EVENT_19
; #LOCALSIZE 5
; #DIM L_INDEX
; CUSTOMDRAWLINE =
; PRINTFORML 어떤 이벤트를 진행합니까？
; CUSTOMDRAWLINE =

; FOR L_INDEX,0,20
; 	FOR LOCAL,0,32
; 		TRYCCALLFORM EVENT_19_LIST_{L_INDEX} , LOCAL,1
; 		CATCH
; 			BREAK
; 		ENDCATCH
; 		SIF !RESULT
; 			CONTINUE
; 		SIF GETBIT(이벤트フラグ:19:L_INDEX,LOCAL)
; 			CONTINUE
; 		CALLFORM EVENT_19_LIST_{L_INDEX} , LOCAL,0
; 		;SIF RESULT == 0
; 		;	CONTINUE
; 		PRINTFORM [{L_INDEX*100+LOCAL,4}] %RESULTS%
; 		PRINTL
; 	NEXT
; NEXT
; PRINTFORML [9999]돌아간다
; $INPUT_LOOP
; INPUT
; SIF RESULT == 9999
; 	RETURN
; LOCAL:3 = RESULT / 100
; LOCAL:4 = RESULT % 100
; TRYCCALLFORM EVENT_19_LIST_{LOCAL:3} , LOCAL:4,1
; 	SIF !RESULT
; 		GOTO END_EVENT
; 	SIF GETBIT(이벤트フラグ:19:(LOCAL:3),LOCAL:4)
; 		GOTO END_EVENT
; 	CALLFORM EVENT_19_LIST_{LOCAL:3} , LOCAL:4,2
; 	;返り値１だと이벤트完了
; 	SIF RESULT == 1
; 		SETBIT 이벤트フラグ:19:(LOCAL:3),LOCAL:4
; 	PRINTL
; 	PRINTL
; 	RESTART
; CATCH
; ENDCATCH
; $END_EVENT
; CLEARLINE 1
; GOTO INPUT_LOOP